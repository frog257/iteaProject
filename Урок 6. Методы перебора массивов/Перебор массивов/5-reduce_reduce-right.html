<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.

Это один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу, которая иначе потребовала бы в разы больше места и времени.

Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.

Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.

Аргументы функции callback(previousValue, currentItem, index, arr):

previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
index – номер текущего элемента.
arr – обрабатываемый массив.
Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

Проще всего понять работу метода reduce на примере.

Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.

Вот решение в одну строку: -->
<!-- <script type="text/javascript">
	var arr = [1, 2, 3, 4, 5]

	var result = arr.reduce(function(sum, current) {
	  return sum + current;
	}, 0);

	document.write( result ); // 15
</script> -->
<!-- Разберём, что в нём происходит.

При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).

Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.

Поток вычислений получается такой


В виде таблицы где каждая строка – вызов функции на очередном элементе массива:

sum	current	результат
первый вызов	0	1	1
второй вызов	1	2	3
третий вызов	3	3	6
четвёртый вызов	6	4	10
пятый вызов	10	5	15
Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.

Кстати, полный набор аргументов функции для reduce включает в себя function(sum, current, i, array), то есть номер текущего вызова i и весь массив arr, но здесь в них нет нужды.

Посмотрим, что будет, если не указать initialValue в вызове arr.reduce: -->
<!-- <script type="text/javascript">
 var arr = [1, 2, 3, 4, 5]

var result = arr.reduce(function(sum, current) {
  return sum + current
});

document.write( result ); 
</script> -->
<!-- Результат – точно такой же! Это потому, что при отсутствии initialValue в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же, за вычетом первой строки.

Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево. -->



<script>
	
	var orders = [
		{ amount: 250, name: 'test1' },
		{ amount: 400, name: 'test2' },
		{ amount: 100, name: 'test3' },
		{ amount: 325, name: 'test4' }
	]		
		// var totalAmount = 0;
		// for (var i = 0; i < orders.length; i++) {
		// 	totalAmount += orders[i].amount;
		// }

	var totalAmount = orders.reduce(function(sum, order) {
		return sum + order.amount;
	}, 0);


	var totalSum = 0;
	orders.forEach(function(item) {
		totalSum += item.amount
	});

	console.log(totalSum);
	
</script>
</body>
</html>